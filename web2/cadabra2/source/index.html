{% extends "layout.html" %}

{% block title %}Cadabra: a field theory motivated approach to computer algebra{% endblock %}

{% block head %}{%- endblock %}

{% block main %}
<h1>Warning</h1>
<p  class="hyphenate">
  This is the web site for the new Cadabra 2.x series. It is currently
  meant for people interested in having a look at what the future will
  bring. Not all functionality of the 1.x series is present in series
  2.x yet, so if you just want to get work done, you probably still want
  to visit the <a href="http://cadabra.phi-sci.com">old site</a> for
  now.
</p>

<h1>What is Cadabra?</h1>
<p  class="hyphenate">
  Cadabra is a symbolic computer algebra system (CAS) designed
  specifically for the solution of problems encountered in field
  theory. It has extensive functionality for tensor computer
  algebra, tensor polynomial simplification including multi-term
  symmetries, fermions and anti-commuting variables, Clifford
  algebras and Fierz transformations, implicit coordinate
  dependence, multiple index types and many more. The input
  format is a subset of TeX. Both a command-line and a graphical
  interface are available.
  <div class="splash_image">
	 <img src="/static/images/screenshot.png" />
  </div>
  <ul>
	 <li>
		Designed for field-theory problems, with handling of
		anti-commuting and non-commuting objects without special notations
		for their products, gamma matrix algebra, Fierz identities, Dirac
		conjugation, vielbeine, flat and curved, covariant and
		contravariant indices, implicit dependence of tensors on
		coordinates, partial and covariant derivatives...
	 </li>
	 <li>
		Powerful tensor simplification algorithms, not just for
		mono-term symmetries but also for multi-terms symmetries like
		the Bianchi identity, or dimensionally-dependent symmetries like
		the Schouten identity.
	 </li>
	 <li>
		A standalone graphical notebook interface which can also be
		used as a front-end for SymPy.
	 </li>
	 <li>
		Input and output using a subset of LaTeX notation.
	 </li>
  </ul>
</ul>
</p>
<br/>

<h1>Cadabra's design philosophy</h1>
<p  class="hyphenate">
  Cadabra is built around the fact that many computations do not have
  one single and unique path between the starting point and the end
  result. When we do computations on paper, we often taken bits of an
  expression apart, do some manipulations on them, stick them back
  into the main expression, and so on. Often, the manipulations that
  we do are far from uniquely determined by the problem, and often
  there is no way even in principle for a computer to figure out what
  is 'the best' thing to do. 
</p>
<p  class="hyphenate">
  What we need the computer to do, in such a case, is to be good at
  performing simple but tedious steps, without enforcing on the user
  how to do a particular computation. In other words, we want the
  computer algebra system to be a scratchpad, leaving us in control of
  which steps to take, not forcing us to return to a 'canonical'
  expression at every stage.
</p>
<p  class="hyphenate">
  Most existing computer algebra systems allow for this kind of work
  flow only by requiring to stick clumsy 'inert' or 'hold' arguments
  onto expressions, by default always 'simplifying' every input to
  some form they think is best. Cadabra starts from the other end of
  the spectrum, and as a general rule keeps your expression untouched, 
  unless you explicitly ask for something to be done to it.
</p>
<br/>

<p>
  <ul>
  </ul>
</p>
<br/>

{%- endblock %}

